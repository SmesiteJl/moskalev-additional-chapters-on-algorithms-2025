# LCS — наибольшая общая подпоследовательность

## 1. Постановка задачи
Даны две строки. Требуется найти длину их наибольшей общей подпоследовательности, то есть максимальной по длине последовательности символов, которая встречается в обеих строках в одинаковом порядке (не обязательно подряд).

---

## 2. Идея решения
Я использовал классический подход динамического программирования, где подзадачи соответствуют первым i символам первой строки и первым j символам второй строки. Каждая такая подзадача зависит от более коротких префиксов.

---

## 3. Выбор алгоритма
Задача обладает оптимальной подструктурой и перекрывающимися подзадачами, поэтому динамическое программирование является естественным и оптимальным способом решения.

---

## 4. Алгоритм в общем виде
1. Создать двумерную таблицу dp размеров (n+1) × (m+1).
2. Заполнить таблицу по правилам:
    - если символы совпадают, увеличить значение на 1,
    - иначе взять максимум из соседних значений.
3. Значение dp[n][m] является длиной LCS.

---

## 5. Корректность
Каждое значение dp[i][j] корректно отражает длину наибольшей общей подпоследовательности для соответствующих префиксов строк. Поскольку все подзадачи вычисляются до использования, итоговое значение dp[n][m] является правильным ответом задачи.

---

## 6. Асимптотическая сложность
Пусть n и m — длины строк.  
Время: O(n · m).  
Память: O(n · m).

---

## 7. Особые случаи
- Пустые строки.
- Полное совпадение строк.
- Полное отсутствие общих символов.
- Повторяющиеся символы.

---

## 8. Связь с теорией
Задача является одной из базовых задач динамического программирования и используется как классический пример оптимальной подструктуры и табличного метода.

---

## 9. Что реализовано в программе
- Построение двумерной таблицы dp.
- Поэтапное заполнение таблицы.
- Вычисление длины наибольшей общей подпоследовательности.
- Вывод результата.
